Index: app/src/main/java/com/maxtauro/airdroid/mainfragment/DeviceStatusFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.maxtauro.airdroid.mainfragment\n\nimport android.bluetooth.BluetoothA2dp\nimport android.bluetooth.BluetoothAdapter\nimport android.bluetooth.BluetoothDevice\nimport android.content.Context\nimport android.content.Intent\nimport android.content.pm.PackageManager\nimport android.os.Bundle\nimport android.os.Handler\nimport android.util.Log\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.core.content.ContextCompat\nimport com.hannesdorfmann.mosby3.mvi.MviFragment\nimport com.jakewharton.rxrelay2.PublishRelay\nimport com.maxtauro.airdroid.EXTRA_DEVICE\nimport com.maxtauro.airdroid.bluetooth.services.BluetoothConnectionService\nimport com.maxtauro.airdroid.bluetooth.services.UnlockService\nimport com.maxtauro.airdroid.mainfragment.presenter.*\nimport com.maxtauro.airdroid.mainfragment.viewmodel.DeviceViewModel\nimport com.maxtauro.airdroid.notification.NotificationService\nimport com.maxtauro.airdroid.notification.NotificationService.Companion.EXTRA_AIRPOD_MODEL\nimport com.maxtauro.airdroid.notification.NotificationService.Companion.EXTRA_AIRPOD_NAME\nimport com.maxtauro.airdroid.orElse\nimport com.maxtauro.airdroid.startServiceIfDeviceUnlocked\nimport io.reactivex.disposables.CompositeDisposable\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.launch\n\nclass DeviceStatusFragment :\n    MviFragment<DeviceStatusContract.View, DeviceStatusContract.Presenter>(),\n    DeviceStatusContract.View {\n\n    private val subscriptions = CompositeDisposable()\n\n    private fun isLocationPermissionEnabled() =\n        context != null && ContextCompat.checkSelfPermission(\n            context!!,\n            android.Manifest.permission.ACCESS_FINE_LOCATION\n        ) == PackageManager.PERMISSION_GRANTED\n\n    private lateinit var view: DeviceFragmentView\n    private var viewModel = DeviceViewModel.createEmptyViewModel(isLocationPermissionEnabled())\n\n    private val connectionState: Int?\n        get() = BluetoothAdapter.getDefaultAdapter()?.getProfileConnectionState(BluetoothA2dp.HEADSET)\n\n    private val actionIntentsRelay = PublishRelay.create<DeviceStatusIntent>().toSerialized()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        getMvpDelegate().onCreate(savedInstanceState)\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        subscriptions.clear()\n    }\n\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        super.onCreateView(inflater, container, savedInstanceState)\n        val view = DeviceFragmentView(inflater, container)\n\n        this.view = view\n        return view.view\n    }\n\n    override fun onResume() {\n        super.onResume()\n\n        // When ever the app comes into the foreground we clear the notification\n        context?.let { stopNotificationService(it) }\n\n        // Here we check if a head set (ie airpods) is connected to our device\n        // Unfortunately there is no way to check is some thing that airpods are connected\n        // So we just start the scan if something might be connected\n        Handler().postDelayed(\n            {\n                if (connectionState == 2 || connectionState == 1) {\n                    activity?.intent?.getStringExtra(EXTRA_AIRPOD_NAME)?.let {\n                        actionIntentsRelay.accept(UpdateNameIntent(it))\n                    }.orElse {\n                        val deviceName =\n                            (activity?.intent?.extras?.get(EXTRA_DEVICE) as? BluetoothDevice)?.name\n                                ?: \"\"\n                        actionIntentsRelay.accept(ConnectedIntent(deviceName))\n                    }\n                }\n            },\n            200\n        )\n    }\n\n    override fun onPause() {\n        super.onPause()\n        actionIntentsRelay.accept(StopScanIntent)\n        if (viewModel.airpods.isConnected ||\n            connectionState == 2 ||\n            connectionState == 1\n        ) {\n            startNotificationService()\n        }\n\n        context?.startServiceIfDeviceUnlocked(Intent(context, UnlockService::class.java))\n    }\n\n    override fun actionIntents() = actionIntentsRelay\n\n    override fun createPresenter() = DeviceStatusPresenter(::isLocationPermissionEnabled)\n\n    override fun render(viewModel: DeviceViewModel) {\n        this.viewModel = viewModel\n        view.render(viewModel)\n    }\n\n    override fun getMvpView(): DeviceStatusContract.View {\n        try {\n            return this\n        } catch (e: ClassCastException) {\n            val msg = \"Couldn't cast the View to the corresponding View interface.\"\n            Log.e(TAG, msg)\n            throw RuntimeException(msg, e)\n        }\n    }\n\n    override fun onSaveInstanceState(outState: Bundle) {\n        outState.putString(EXTRA_AIRPOD_NAME, viewModel.deviceName)\n        super.onSaveInstanceState(outState)\n    }\n\n    fun startBluetoothService() {\n        Intent(activity, BluetoothConnectionService::class.java).also { intent ->\n            activity?.startServiceIfDeviceUnlocked(intent)\n        }\n    }\n\n    private fun startNotificationService() {\n        Intent(activity, NotificationService::class.java).also { intent ->\n            intent.putExtra(EXTRA_AIRPOD_MODEL, viewModel.airpods)\n            intent.putExtra(EXTRA_AIRPOD_NAME, viewModel.deviceName)\n            activity?.startServiceIfDeviceUnlocked(intent)\n        }\n    }\n\n    private fun stopNotificationService(context: Context) = GlobalScope.launch(Dispatchers.Main) {\n        NotificationService.clearNotification(context)\n        Intent(activity, NotificationService::class.java).also { intent ->\n            activity?.stopService(intent)\n        }\n    }\n\n    companion object {\n        private const val TAG = \"DeviceStatusFragment\"\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/maxtauro/airdroid/mainfragment/DeviceStatusFragment.kt	(date 1567693487000)
+++ app/src/main/java/com/maxtauro/airdroid/mainfragment/DeviceStatusFragment.kt	(date 1568046513000)
@@ -7,7 +7,6 @@
 import android.content.Intent
 import android.content.pm.PackageManager
 import android.os.Bundle
-import android.os.Handler
 import android.util.Log
 import android.view.LayoutInflater
 import android.view.View
@@ -21,10 +20,10 @@
 import com.maxtauro.airdroid.mainfragment.presenter.*
 import com.maxtauro.airdroid.mainfragment.viewmodel.DeviceViewModel
 import com.maxtauro.airdroid.notification.NotificationService
-import com.maxtauro.airdroid.notification.NotificationService.Companion.EXTRA_AIRPOD_MODEL
 import com.maxtauro.airdroid.notification.NotificationService.Companion.EXTRA_AIRPOD_NAME
 import com.maxtauro.airdroid.orElse
 import com.maxtauro.airdroid.startServiceIfDeviceUnlocked
+import com.maxtauro.airdroid.utils.NotificationJobSchedulerUtil
 import io.reactivex.disposables.CompositeDisposable
 import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.GlobalScope
@@ -75,27 +74,23 @@
     override fun onResume() {
         super.onResume()
 
-        // When ever the app comes into the foreground we clear the notification
+        // Whenever the app comes into the foreground we clear the notification
         context?.let { stopNotificationService(it) }
 
         // Here we check if a head set (ie airpods) is connected to our device
         // Unfortunately there is no way to check is some thing that airpods are connected
         // So we just start the scan if something might be connected
-        Handler().postDelayed(
-            {
-                if (connectionState == 2 || connectionState == 1) {
-                    activity?.intent?.getStringExtra(EXTRA_AIRPOD_NAME)?.let {
-                        actionIntentsRelay.accept(UpdateNameIntent(it))
-                    }.orElse {
-                        val deviceName =
-                            (activity?.intent?.extras?.get(EXTRA_DEVICE) as? BluetoothDevice)?.name
-                                ?: ""
-                        actionIntentsRelay.accept(ConnectedIntent(deviceName))
-                    }
-                }
-            },
-            200
-        )
+        if (connectionState == 2 || connectionState == 1) {
+            activity?.intent?.getStringExtra(EXTRA_AIRPOD_NAME)?.let {
+                actionIntentsRelay.accept(UpdateNameIntent(it))
+            }.orElse {
+                val deviceName =
+                    (activity?.intent?.extras?.get(EXTRA_DEVICE) as? BluetoothDevice)?.name
+                        ?: ""
+                actionIntentsRelay.accept(ConnectedIntent(deviceName))
+            }
+        }
+
     }
 
     override fun onPause() {
@@ -105,7 +100,7 @@
             connectionState == 2 ||
             connectionState == 1
         ) {
-            startNotificationService()
+            context?.let { scheduleNotificationJob(it) }
         }
 
         context?.startServiceIfDeviceUnlocked(Intent(context, UnlockService::class.java))
@@ -141,12 +136,12 @@
         }
     }
 
-    private fun startNotificationService() {
-        Intent(activity, NotificationService::class.java).also { intent ->
-            intent.putExtra(EXTRA_AIRPOD_MODEL, viewModel.airpods)
-            intent.putExtra(EXTRA_AIRPOD_NAME, viewModel.deviceName)
-            activity?.startServiceIfDeviceUnlocked(intent)
-        }
+    private fun scheduleNotificationJob(context: Context) {
+        NotificationJobSchedulerUtil.scheduleJob(
+            context = context,
+            airpodModel = viewModel.airpods,
+            deviceName = viewModel.deviceName
+        )
     }
 
     private fun stopNotificationService(context: Context) = GlobalScope.launch(Dispatchers.Main) {
Index: app/src/main/java/com/maxtauro/airdroid/bluetooth/receivers/BluetoothConnectionReceiver.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.maxtauro.airdroid.bluetooth.receivers\n\nimport android.bluetooth.BluetoothA2dp\nimport android.bluetooth.BluetoothAdapter\nimport android.bluetooth.BluetoothDevice\nimport android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.util.Log\nimport com.maxtauro.airdroid.*\nimport com.maxtauro.airdroid.mainfragment.presenter.ConnectedIntent\nimport com.maxtauro.airdroid.mainfragment.presenter.DisconnectedIntent\nimport com.maxtauro.airdroid.notification.NotificationService\nimport org.greenrobot.eventbus.EventBus\n\nclass BluetoothConnectionReceiver : BroadcastReceiver() {\n\n    private val eventBus = EventBus.getDefault()\n\n    private val isActivityInForegroud: Boolean\n        get() = mIsActivityRunning\n\n    private val isConnected: Boolean\n        get() = BluetoothAdapter.getDefaultAdapter().getProfileConnectionState(BluetoothA2dp.HEADSET) == 1 ||\n                BluetoothAdapter.getDefaultAdapter().getProfileConnectionState(BluetoothA2dp.HEADSET) == 2\n\n    override fun onReceive(context: Context?, intent: Intent?) {\n        if (intent == null) return\n\n        when (intent.action) {\n            BluetoothDevice.ACTION_ACL_CONNECTED -> handleBluetoothConnected(intent, context)\n            BluetoothDevice.ACTION_ACL_DISCONNECTED -> handleBluetoothDisconnected(intent, context)\n            Intent.ACTION_BOOT_COMPLETED,\n            Intent.ACTION_MY_PACKAGE_REPLACED,\n            Intent.ACTION_PACKAGE_INSTALL -> {\n            }//TODO handle reboot\n        }\n    }\n\n    private fun handleBluetoothDisconnected(intent: Intent, context: Context?) {\n        val disconnectedDevice = intent.extras[BluetoothDevice.EXTRA_DEVICE] as? BluetoothDevice\n        disconnectedDevice?.let {\n            Log.d(\n                TAG,\n                \"Device Disconnected, Name: ${disconnectedDevice.name}, Address: ${disconnectedDevice.address}\"\n            )\n        }\n        if (isActivityInForegroud) {\n            eventBus.post(DisconnectedIntent)\n        } else {\n            context?.let {\n                NotificationService.clearNotification(context)\n                Intent(context, NotificationService::class.java).also {\n                    context.stopService(it)\n                }\n            }\n        }\n    }\n\n    private fun handleBluetoothConnected(intent: Intent, context: Context?) {\n        val connectedDevice = intent.extras[BluetoothDevice.EXTRA_DEVICE] as? BluetoothDevice\n        connectedDevice?.let {\n            Log.d(\n                TAG,\n                \"Device Connected, Name: ${connectedDevice.name}, Address: ${connectedDevice.address}\"\n            )\n\n            if (isActivityInForegroud) {\n                eventBus.post(ConnectedIntent(connectedDevice.name))\n            } else {\n                val preferences =\n                    context?.getSharedPreferences(SHARED_PREFERENCE_FILE_NAME, Context.MODE_PRIVATE)\n                        ?: throw IllegalStateException(\"Preferences haven't been initialized yet\")\n\n                val isOpenAppEnabled = preferences.getBoolean(OPEN_APP_PREF_KEY, true)\n                val isNotificationEnabled = preferences.getBoolean(NOTIFICATION_PREF_KEY, true)\n\n                if (isOpenAppEnabled) startMainActivity(context, connectedDevice)\n                else if (isNotificationEnabled) startNotificationService(context, connectedDevice)\n            }\n        }\n    }\n\n    private fun startNotificationService(context: Context, connectedDevice: BluetoothDevice) {\n        Intent(context, NotificationService::class.java).also { intent ->\n            intent.putExtra(NotificationService.EXTRA_AIRPOD_NAME, connectedDevice.name)\n            context.startServiceIfDeviceUnlocked(intent)\n        }\n    }\n\n    private fun startMainActivity(context: Context?, connectedDevice: BluetoothDevice) {\n        Intent(context, MainActivity::class.java).also { intent ->\n            intent.putExtra(EXTRA_DEVICE, connectedDevice)\n            intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK\n            context?.startActivity(intent)\n        }\n    }\n\n    companion object {\n        private const val TAG = \"BluetoothConnectionReceiver\"\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/maxtauro/airdroid/bluetooth/receivers/BluetoothConnectionReceiver.kt	(date 1567693487000)
+++ app/src/main/java/com/maxtauro/airdroid/bluetooth/receivers/BluetoothConnectionReceiver.kt	(date 1568053123000)
@@ -1,5 +1,6 @@
 package com.maxtauro.airdroid.bluetooth.receivers
 
+import android.annotation.SuppressLint
 import android.bluetooth.BluetoothA2dp
 import android.bluetooth.BluetoothAdapter
 import android.bluetooth.BluetoothDevice
@@ -10,9 +11,11 @@
 import com.maxtauro.airdroid.*
 import com.maxtauro.airdroid.mainfragment.presenter.ConnectedIntent
 import com.maxtauro.airdroid.mainfragment.presenter.DisconnectedIntent
-import com.maxtauro.airdroid.notification.NotificationService
+import com.maxtauro.airdroid.utils.NotificationJobSchedulerUtil
+import com.maxtauro.airdroid.utils.NotificationUtil
 import org.greenrobot.eventbus.EventBus
 
+@SuppressLint("LongLogTag")
 class BluetoothConnectionReceiver : BroadcastReceiver() {
 
     private val eventBus = EventBus.getDefault()
@@ -49,10 +52,9 @@
             eventBus.post(DisconnectedIntent)
         } else {
             context?.let {
-                NotificationService.clearNotification(context)
-                Intent(context, NotificationService::class.java).also {
-                    context.stopService(it)
-                }
+                cancelNotificationJob(it)
+                NotificationUtil.clearNotification(it)
+
             }
         }
     }
@@ -75,17 +77,24 @@
                 val isOpenAppEnabled = preferences.getBoolean(OPEN_APP_PREF_KEY, true)
                 val isNotificationEnabled = preferences.getBoolean(NOTIFICATION_PREF_KEY, true)
 
-                if (isOpenAppEnabled) startMainActivity(context, connectedDevice)
-                else if (isNotificationEnabled) startNotificationService(context, connectedDevice)
+                if (isOpenAppEnabled && context.isDeviceUnlocked()) startMainActivity(
+                    context,
+                    connectedDevice
+                )
+                else if (isNotificationEnabled) scheduleNotificationJob(context, connectedDevice)
             }
         }
     }
 
-    private fun startNotificationService(context: Context, connectedDevice: BluetoothDevice) {
-        Intent(context, NotificationService::class.java).also { intent ->
-            intent.putExtra(NotificationService.EXTRA_AIRPOD_NAME, connectedDevice.name)
-            context.startServiceIfDeviceUnlocked(intent)
-        }
+    private fun scheduleNotificationJob(context: Context, connectedDevice: BluetoothDevice) {
+        NotificationJobSchedulerUtil.scheduleJob(
+            context = context,
+            deviceName = connectedDevice.name
+        )
+    }
+
+    private fun cancelNotificationJob(context: Context) {
+        NotificationJobSchedulerUtil.cancelJob(context)
     }
 
     private fun startMainActivity(context: Context?, connectedDevice: BluetoothDevice) {
Index: app/src/main/java/com/maxtauro/airdroid/bluetooth/services/NotificationJobService.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/maxtauro/airdroid/bluetooth/services/NotificationJobService.kt	(date 1568062205000)
+++ app/src/main/java/com/maxtauro/airdroid/bluetooth/services/NotificationJobService.kt	(date 1568062205000)
@@ -0,0 +1,52 @@
+package com.maxtauro.airdroid.bluetooth.services
+
+import android.app.job.JobParameters
+import android.app.job.JobService
+import android.bluetooth.le.ScanSettings
+import android.content.Intent
+import android.util.Log
+import com.maxtauro.airdroid.bluetooth.callbacks.AirpodLeScanCallback
+import com.maxtauro.airdroid.utils.BluetoothScannerUtil
+import com.maxtauro.airdroid.utils.NotificationUtil
+
+class NotificationJobService : JobService() {
+
+    private val notificationUtil = NotificationUtil(baseContext, packageName)
+    private val scannerUtil = BluetoothScannerUtil()
+
+    private val scanCallback = AirpodLeScanCallback(notificationUtil::onScanResult)
+
+    override fun onStartJob(params: JobParameters?): Boolean {
+        if (notificationUtil.isNotificationEnabled) {
+            Log.d(TAG, "Starting job")
+
+//            intent?.getStringExtra(NotificationService.EXTRA_AIRPOD_NAME)?.let { airpodName = it }
+//            (intent?.getParcelableExtra(NotificationService.EXTRA_AIRPOD_MODEL) as? AirpodModel)?.let {
+//                airpodModel = it
+//                renderNotification(it)
+//            }
+
+            scannerUtil.startScan(scanCallback, ScanSettings.SCAN_MODE_LOW_POWER)
+
+            return true
+        }
+
+        return true
+    }
+
+    override fun onStopJob(params: JobParameters?): Boolean {
+        Log.d(TAG, "onStopJob w/ params: $params")
+        scannerUtil.stopScan()
+        NotificationUtil.clearNotification(baseContext)
+        return true
+    }
+
+    override fun onTaskRemoved(rootIntent: Intent?) {
+        NotificationUtil.clearNotification(baseContext)
+        super.onTaskRemoved(rootIntent)
+    }
+
+    companion object {
+        private const val TAG = "NotificationJobService"
+    }
+}
\ No newline at end of file
Index: app/src/main/java/com/maxtauro/airdroid/utils/BluetoothScannerUtil.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.maxtauro.airdroid.utils\n\nimport android.bluetooth.BluetoothAdapter\nimport android.bluetooth.le.ScanCallback\nimport android.bluetooth.le.ScanFilter\nimport android.bluetooth.le.ScanResult\nimport android.bluetooth.le.ScanSettings\nimport android.util.Log\n\nclass BluetoothScannerUtil {\n\n    private val bluetoothAdapter = BluetoothAdapter.getDefaultAdapter()\n\n    private val scanner = bluetoothAdapter?.bluetoothLeScanner\n    private val scanFilters = getScanFilters()\n\n    var isScanning: Boolean = false\n        private set\n\n    fun startScan(scanCallback: ScanCallback, scanMode: Int) {\n        if (isScanning) return\n\n        val scanSettings = ScanSettings.Builder().setScanMode(scanMode).setReportDelay(2).build()\n\n        Log.d(TAG, \"Starting bluetooth scan\")\n        scanner?.startScan(scanFilters, scanSettings, scanCallback)\n        isScanning = true\n    }\n\n    private fun getScanFilters(): List<ScanFilter> {\n        val manufacturerData = ByteArray(27)\n        val manufacturerDataMask = ByteArray(27)\n\n        manufacturerData[0] = 7\n        manufacturerData[1] = 25\n\n        manufacturerDataMask[0] = -1\n        manufacturerDataMask[1] = -1\n\n        val builder = ScanFilter.Builder()\n        builder.setManufacturerData(76, manufacturerData, manufacturerDataMask)\n        return listOf(builder.build())\n    }\n\n    fun stopScan() {\n        scanner?.stopScan(object : ScanCallback() {\n            override fun onScanResult(callbackType: Int, result: ScanResult) {\n            }\n        })\n\n        isScanning = false\n    }\n\n    companion object {\n        private const val TAG = \"BluetoothScannerUtil\"\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/maxtauro/airdroid/utils/BluetoothScannerUtil.kt	(date 1567693487000)
+++ app/src/main/java/com/maxtauro/airdroid/utils/BluetoothScannerUtil.kt	(date 1568063498000)
@@ -45,10 +45,14 @@
     fun stopScan() {
         scanner?.stopScan(object : ScanCallback() {
             override fun onScanResult(callbackType: Int, result: ScanResult) {
-            }
-        })
+                scanner.flushPendingScanResults(object : ScanCallback() {
+                    override fun onScanResult(callbackType: Int, result: ScanResult) {}
+                })
 
-        isScanning = false
+                isScanning = false
+                Log.d(TAG, "Scan Stopped")
+            }
+        })
     }
 
     companion object {
Index: app/src/main/java/com/maxtauro/airdroid/notification/NotificationService.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.maxtauro.airdroid.notification\n\nimport android.app.*\nimport android.bluetooth.le.ScanSettings\nimport android.content.Context\nimport android.content.Intent\nimport android.content.SharedPreferences\nimport android.os.Build\nimport android.os.IBinder\nimport android.util.Log\nimport androidx.core.app.NotificationCompat\nimport com.maxtauro.airdroid.*\nimport com.maxtauro.airdroid.bluetooth.callbacks.AirpodLeScanCallback\nimport com.maxtauro.airdroid.mainfragment.presenter.RefreshIntent\nimport com.maxtauro.airdroid.mainfragment.presenter.UpdateNameIntent\nimport com.maxtauro.airdroid.utils.BluetoothScannerUtil\nimport org.greenrobot.eventbus.EventBus\n\nclass NotificationService : Service() {\n\n    private val scannerUtil = BluetoothScannerUtil()\n\n    private val scanCallback = AirpodLeScanCallback(::onScanResult)\n\n    private lateinit var preferences: SharedPreferences\n\n    private var isNotificationEnabled = true\n\n    private lateinit var notificationManager: NotificationManager\n    private lateinit var notificationBuilder: NotificationCompat.Builder\n\n    private lateinit var largeNotificationView: NotificationView\n    private lateinit var smallNotificationView: NotificationView\n\n    private lateinit var airpodName: String\n    private lateinit var airpodModel: AirpodModel\n\n    override fun onCreate() {\n        super.onCreate()\n\n        bindViews()\n\n        preferences = baseContext?.getSharedPreferences(SHARED_PREFERENCE_FILE_NAME ,Context.MODE_PRIVATE)\n            ?: throw IllegalStateException(\"Preferences haven't been initialized yet\")\n\n        isNotificationEnabled = preferences.getBoolean(NOTIFICATION_PREF_KEY, true)\n\n        notificationManager = baseContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\n        notificationBuilder = NotificationCompat.Builder(baseContext, TAG)\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { //on oreo and newer, create a notification channel\n            val channel = NotificationChannel(TAG, TAG, NotificationManager.IMPORTANCE_DEFAULT)\n            channel.enableVibration(false)\n            channel.enableLights(false)\n            channel.setSound(null, null)\n            channel.setShowBadge(true)\n            channel.lockscreenVisibility = Notification.VISIBILITY_PUBLIC\n            notificationManager.createNotificationChannel(channel)\n        }\n\n        notificationBuilder.setShowWhen(false)\n        notificationBuilder.setOngoing(true)\n\n        notificationBuilder.setCustomContentView(smallNotificationView)\n        notificationBuilder.setCustomBigContentView(largeNotificationView)\n    }\n\n    private fun bindViews() {\n        largeNotificationView = NotificationView(isLargeNotification = true, packageName = packageName)\n        smallNotificationView = NotificationView(isLargeNotification = false, packageName = packageName)\n    }\n\n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        if (isNotificationEnabled) {\n            Log.d(TAG, \"Starting NotificationService\")\n\n            intent?.getStringExtra(EXTRA_AIRPOD_NAME)?.let { airpodName = it }\n            (intent?.getParcelableExtra(EXTRA_AIRPOD_MODEL) as? AirpodModel)?.let {\n                airpodModel = it\n                renderNotification(it)\n            }\n\n            scannerUtil.startScan(\n                scanCallback = scanCallback,\n                scanMode = if (mIsActivityRunning) {\n                    ScanSettings.SCAN_MODE_LOW_LATENCY\n                } else {\n                    ScanSettings.SCAN_MODE_LOW_POWER\n                })\n        }\n\n        return super.onStartCommand(intent, flags, startId)\n    }\n\n    override fun onBind(intent: Intent?): IBinder? {\n        return null\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n\n        // TODO find a way to do this without using event bus\n        if (::airpodModel.isInitialized) EventBus.getDefault().post(RefreshIntent(airpodModel))\n        if (::airpodName.isInitialized) EventBus.getDefault().post(UpdateNameIntent(airpodName))\n\n        scannerUtil.stopScan()\n    }\n\n    private fun onScanResult(airpodModel: AirpodModel) {\n        if (scannerUtil.isScanning) {\n            renderNotification(airpodModel)\n        }\n    }\n\n    private fun renderNotification(airpodModel: AirpodModel) {\n        if (airpodModel.isConnected && isNotificationEnabled) {\n            this.airpodModel = airpodModel\n\n            if (airpodModel.leftAirpod.isConnected && !airpodModel.rightAirpod.isConnected) {\n                notificationBuilder.setSmallIcon(R.mipmap.left_airpod_notification_icon)\n            } else if (!airpodModel.leftAirpod.isConnected && airpodModel.rightAirpod.isConnected) {\n                notificationBuilder.setSmallIcon(R.mipmap.right_airpod_notification_icon)\n            } else {\n                notificationBuilder.setSmallIcon(R.mipmap.both_airpods_notification_icon)\n            }\n\n            notificationBuilder.setContentIntent(buildContentIntent(airpodModel))\n\n            largeNotificationView.render(airpodModel)\n            smallNotificationView.render(airpodModel)\n            notificationManager.notify(1, notificationBuilder.build())\n        } else clearNotification(baseContext)\n    }\n\n    private fun buildContentIntent(airpodModel: AirpodModel): PendingIntent? {\n        val intent = Intent(applicationContext, MainActivity::class.java)\n        intent.putExtra(EXTRA_AIRPOD_MODEL, airpodModel)\n        return PendingIntent.getActivity(\n            this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT\n        )\n    }\n\n    companion object {\n        const val EXTRA_AIRPOD_MODEL = \"EXTRA_AIRPOD_MODEL\"\n        const val EXTRA_AIRPOD_NAME = \"EXTRA_AIRPOD_NAME\"\n\n        private const val TAG = \"NotificationService\"\n\n        fun clearNotification(context: Context) {\n            Log.d(TAG, \"Clearing notification from: $context\")\n            val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\n            notificationManager.cancelAll()\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/maxtauro/airdroid/notification/NotificationService.kt	(date 1567693487000)
+++ app/src/main/java/com/maxtauro/airdroid/notification/NotificationService.kt	(date 1567996801000)
@@ -16,6 +16,7 @@
 import com.maxtauro.airdroid.utils.BluetoothScannerUtil
 import org.greenrobot.eventbus.EventBus
 
+@Deprecated("Replacing with NotificationJobService")
 class NotificationService : Service() {
 
     private val scannerUtil = BluetoothScannerUtil()
@@ -106,6 +107,11 @@
         scannerUtil.stopScan()
     }
 
+    override fun onTaskRemoved(rootIntent: Intent?) {
+        clearNotification(applicationContext)
+        super.onTaskRemoved(rootIntent)
+    }
+
     private fun onScanResult(airpodModel: AirpodModel) {
         if (scannerUtil.isScanning) {
             renderNotification(airpodModel)
Index: app/src/main/java/com/maxtauro/airdroid/utils/NotificationUtil.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/maxtauro/airdroid/utils/NotificationUtil.kt	(date 1568062595000)
+++ app/src/main/java/com/maxtauro/airdroid/utils/NotificationUtil.kt	(date 1568062595000)
@@ -0,0 +1,124 @@
+package com.maxtauro.airdroid.utils
+
+import android.app.Notification
+import android.app.NotificationChannel
+import android.app.NotificationManager
+import android.app.PendingIntent
+import android.content.Context
+import android.content.Intent
+import android.content.SharedPreferences
+import android.os.Build
+import android.util.Log
+import androidx.core.app.NotificationCompat
+import com.maxtauro.airdroid.*
+import com.maxtauro.airdroid.notification.NotificationView
+
+class NotificationUtil(
+    private val context: Context,
+    packageName: String
+) {
+
+    private lateinit var preferences: SharedPreferences
+
+    private lateinit var notificationManager: NotificationManager
+    private lateinit var notificationBuilder: NotificationCompat.Builder
+
+    private lateinit var largeNotificationView: NotificationView
+    private lateinit var smallNotificationView: NotificationView
+
+    private lateinit var airpodName: String
+    private lateinit var airpodModel: AirpodModel
+
+    val isNotificationEnabled: Boolean
+    get() = preferences.getBoolean(NOTIFICATION_PREF_KEY, true)
+
+    init {
+        initializeNotificationUtil()
+        bindViews(packageName)
+    }
+
+    private fun initializeNotificationUtil() {
+        preferences = context.getSharedPreferences(
+            SHARED_PREFERENCE_FILE_NAME, Context.MODE_PRIVATE
+        )
+            ?: throw IllegalStateException("Preferences haven't been initialized yet")
+
+        notificationManager =
+            context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+        notificationBuilder = NotificationCompat.Builder(context, TAG)
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { //on oreo and newer, create a notification channel
+            val channel = NotificationChannel(TAG, TAG, NotificationManager.IMPORTANCE_DEFAULT)
+            channel.enableVibration(false)
+            channel.enableLights(false)
+            channel.setSound(null, null)
+            channel.setShowBadge(true)
+            channel.lockscreenVisibility = Notification.VISIBILITY_PUBLIC
+            notificationManager.createNotificationChannel(channel)
+        }
+
+        notificationBuilder.setShowWhen(false)
+        notificationBuilder.setOngoing(true)
+
+        notificationBuilder.setCustomContentView(smallNotificationView)
+        notificationBuilder.setCustomBigContentView(largeNotificationView)
+    }
+
+    private fun bindViews(packageName: String) {
+        largeNotificationView =
+            NotificationView(isLargeNotification = true, packageName = packageName)
+        smallNotificationView =
+            NotificationView(isLargeNotification = false, packageName = packageName)
+    }
+
+     fun onScanResult(airpodModel: AirpodModel) {
+         Log.d(TAG, "onScanResult")
+        if (airpodModel.isConnected) {
+            renderNotification(airpodModel)
+        } else clearNotification(context)
+    }
+
+    private fun renderNotification(airpodModel: AirpodModel) {
+
+        if (airpodModel.isConnected && isNotificationEnabled) {
+            this.airpodModel = airpodModel
+
+            if (airpodModel.leftAirpod.isConnected && !airpodModel.rightAirpod.isConnected) {
+                notificationBuilder.setSmallIcon(R.mipmap.left_airpod_notification_icon)
+            } else if (!airpodModel.leftAirpod.isConnected && airpodModel.rightAirpod.isConnected) {
+                notificationBuilder.setSmallIcon(R.mipmap.right_airpod_notification_icon)
+            } else {
+                notificationBuilder.setSmallIcon(R.mipmap.both_airpods_notification_icon)
+            }
+
+            notificationBuilder.setContentIntent(buildContentIntent(airpodModel))
+
+            largeNotificationView.render(airpodModel)
+            smallNotificationView.render(airpodModel)
+            notificationManager.notify(1, notificationBuilder.build())
+        }
+    }
+
+    private fun buildContentIntent(airpodModel: AirpodModel): PendingIntent? {
+        val intent = Intent(context, MainActivity::class.java)
+        intent.putExtra(EXTRA_AIRPOD_MODEL, airpodModel)
+        return PendingIntent.getActivity(
+            context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT
+        )
+    }
+
+    companion object {
+
+        const val EXTRA_AIRPOD_MODEL = "EXTRA_AIRPOD_MODEL"
+        const val EXTRA_AIRPOD_NAME = "EXTRA_AIRPOD_NAME"
+
+        private const val TAG = "NotificationUtil"
+
+        fun clearNotification(context: Context) {
+            Log.d(TAG, "Clearing notification from: $context")
+            val notificationManager =
+                context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+            notificationManager.cancelAll()
+        }
+    }
+}
\ No newline at end of file
Index: app/src/main/java/com/maxtauro/airdroid/Constants.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.maxtauro.airdroid\n\nimport android.app.KeyguardManager\nimport android.content.Context\nimport android.content.Intent\nimport android.util.Log\nimport com.crashlytics.android.Crashlytics\n\nconst val EXTRA_DEVICE_ADDRESS = \"DEVICE_ADDRESS\"\nconst val EXTRA_DEVICE = \"EXTRA_DEVICE\"\n\nconst val TEST_AD_UNIT_ID = \"ca-app-pub-3940256099942544/6300978111\"\n\nconst val SHARED_PREFERENCE_FILE_NAME = \"AirDroid.SHARED_PREFERENCE_FILE_NAME\"\nconst val NOTIFICATION_PREF_KEY = \"9999\"\nconst val OPEN_APP_PREF_KEY = \"9998\"\n\ninline fun <R> R?.orElse(block: () -> R): R {\n    return this ?: block()\n}\n\nfun Context?.startServiceIfDeviceUnlocked(intent: Intent) {\n    val keyguardManager = this?.getSystemService(Context.KEYGUARD_SERVICE) as KeyguardManager\n    if (!keyguardManager.isKeyguardLocked) {\n        this.startService(intent)\n        Log.d(this.javaClass.simpleName, \"Started service with intent: $intent\")\n    } else {\n        val msg = \"Device locked, did not start service with intent: $intent\"\n        Crashlytics.logException(IllegalStateException(msg))\n        Log.d(this.javaClass.simpleName, msg)\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/maxtauro/airdroid/Constants.kt	(date 1567693487000)
+++ app/src/main/java/com/maxtauro/airdroid/Constants.kt	(date 1568046112000)
@@ -7,26 +7,32 @@
 import com.crashlytics.android.Crashlytics
 
 const val EXTRA_DEVICE_ADDRESS = "DEVICE_ADDRESS"
+
 const val EXTRA_DEVICE = "EXTRA_DEVICE"
-
 const val TEST_AD_UNIT_ID = "ca-app-pub-3940256099942544/6300978111"
 
 const val SHARED_PREFERENCE_FILE_NAME = "AirDroid.SHARED_PREFERENCE_FILE_NAME"
+
 const val NOTIFICATION_PREF_KEY = "9999"
 const val OPEN_APP_PREF_KEY = "9998"
-
 inline fun <R> R?.orElse(block: () -> R): R {
     return this ?: block()
 }
 
-fun Context?.startServiceIfDeviceUnlocked(intent: Intent) {
+fun Context?.isDeviceUnlocked(): Boolean{
     val keyguardManager = this?.getSystemService(Context.KEYGUARD_SERVICE) as KeyguardManager
-    if (!keyguardManager.isKeyguardLocked) {
-        this.startService(intent)
-        Log.d(this.javaClass.simpleName, "Started service with intent: $intent")
+    return !keyguardManager.isKeyguardLocked
+}
+
+fun Context?.startServiceIfDeviceUnlocked(intent: Intent) {
+    if (!isDeviceUnlocked() && mIsActivityRunning) {
+        this?.let {
+            this.startService(intent)
+            Log.d(this.javaClass.simpleName, "Started service with intent: $intent")
+        }
     } else {
         val msg = "Device locked, did not start service with intent: $intent"
         Crashlytics.logException(IllegalStateException(msg))
-        Log.d(this.javaClass.simpleName, msg)
+        Log.d(this?.javaClass?.simpleName, msg)
     }
-}
\ No newline at end of file
+}
Index: app/src/main/java/com/maxtauro/airdroid/utils/NotificationJobSchedulerUtil.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/maxtauro/airdroid/utils/NotificationJobSchedulerUtil.kt	(date 1568062347000)
+++ app/src/main/java/com/maxtauro/airdroid/utils/NotificationJobSchedulerUtil.kt	(date 1568062347000)
@@ -0,0 +1,41 @@
+package com.maxtauro.airdroid.utils
+
+import android.annotation.SuppressLint
+import android.app.job.JobInfo
+import android.app.job.JobScheduler
+import android.content.ComponentName
+import android.content.Context
+import android.util.Log
+import androidx.core.content.ContextCompat.getSystemService
+import com.maxtauro.airdroid.AirpodModel
+import com.maxtauro.airdroid.bluetooth.services.NotificationJobService
+
+@SuppressLint("LongLogTag")
+object NotificationJobSchedulerUtil {
+
+    private const val TAG = "NotificationJobSchedulerUtil"
+    private const val JOB_ID = 1001
+
+    // schedule the start of the service every 30 seconds
+    fun scheduleJob(
+        context: Context,
+        airpodModel: AirpodModel? = null,
+        deviceName: String? = null
+    ) {
+        Log.d(TAG, "Attempting to schedule Notification Job")
+
+        val serviceComponent = ComponentName(context, NotificationJobService::class.java)
+        val builder = JobInfo.Builder(JOB_ID, serviceComponent)
+        builder.setPeriodic(5000L) // will try to scan every 5s
+        val jobScheduler = getSystemService(context, JobScheduler::class.java)
+        jobScheduler?.schedule(builder.build())
+
+        Log.d(TAG, "Notification Job Scheduled")
+    }
+
+    fun cancelJob(context: Context) {
+        val jobScheduler = getSystemService(context, JobScheduler::class.java)
+        jobScheduler?.cancel(JOB_ID)
+        Log.d(TAG, "Notification Job Canceled")
+    }
+}
\ No newline at end of file
Index: app/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        package=\"com.maxtauro.airdroid\">\n\n    <uses-permission android:name=\"android.permission.BLUETOOTH\"/>\n    <uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\"/>\n    <uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\"/>\n    <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/>\n    <uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"/>\n\n    <uses-feature\n        android:name=\"android.hardware.bluetooth_le\"\n        android:required=\"true\"/>\n\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme.Transparent\">\n\n        <meta-data\n                android:name=\"com.google.android.gms.ads.APPLICATION_ID\"\n                android:value=\"@string/APP_AD_ID\"/>\n\n        <activity android:name=\"com.maxtauro.airdroid.MainActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\"/>\n\n                <category android:name=\"android.intent.category.LAUNCHER\"/>\n            </intent-filter>\n        </activity>\n\n        <receiver android:name=\"com.maxtauro.airdroid.bluetooth.receivers.BluetoothConnectionReceiver\"  android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.BOOT_COMPLETED\" />\n                <action android:name=\"android.intent.action.MY_PACKAGE_REPLACED\" />\n                <action android:name=\"android.intent.action.PACKAGE_INSTALL\" />\n                <action android:name=\"android.bluetooth.device.action.ACL_CONNECTED\" />\n                <action android:name=\"android.bluetooth.device.action.ACL_DISCONNECTED\" />\n            </intent-filter>\n        </receiver>\n\n        <service android:name=\"com.maxtauro.airdroid.bluetooth.services.BluetoothConnectionService\"/>\n        <service android:name=\"com.maxtauro.airdroid.notification.NotificationService\"/>\n        <service android:name=\"com.maxtauro.airdroid.bluetooth.services.UnlockService\"/>\n    </application>\n\n</manifest>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/AndroidManifest.xml	(date 1567693487000)
+++ app/src/main/AndroidManifest.xml	(date 1567996801000)
@@ -2,37 +2,39 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
         package="com.maxtauro.airdroid">
 
-    <uses-permission android:name="android.permission.BLUETOOTH"/>
-    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/>
-    <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
-    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
-    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
+    <uses-permission android:name="android.permission.BLUETOOTH" />
+    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
+    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
+    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
+    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
 
     <uses-feature
-        android:name="android.hardware.bluetooth_le"
-        android:required="true"/>
+            android:name="android.hardware.bluetooth_le"
+            android:required="true" />
 
     <application
-        android:allowBackup="true"
-        android:icon="@mipmap/ic_launcher"
-        android:label="@string/app_name"
-        android:roundIcon="@mipmap/ic_launcher"
-        android:supportsRtl="true"
-        android:theme="@style/AppTheme.Transparent">
+            android:allowBackup="true"
+            android:icon="@mipmap/ic_launcher"
+            android:label="@string/app_name"
+            android:roundIcon="@mipmap/ic_launcher"
+            android:supportsRtl="true"
+            android:theme="@style/AppTheme.Transparent">
 
         <meta-data
                 android:name="com.google.android.gms.ads.APPLICATION_ID"
-                android:value="@string/APP_AD_ID"/>
+                android:value="@string/APP_AD_ID" />
 
         <activity android:name="com.maxtauro.airdroid.MainActivity">
             <intent-filter>
-                <action android:name="android.intent.action.MAIN"/>
+                <action android:name="android.intent.action.MAIN" />
 
-                <category android:name="android.intent.category.LAUNCHER"/>
+                <category android:name="android.intent.category.LAUNCHER" />
             </intent-filter>
         </activity>
 
-        <receiver android:name="com.maxtauro.airdroid.bluetooth.receivers.BluetoothConnectionReceiver"  android:exported="true">
+        <receiver
+                android:name="com.maxtauro.airdroid.bluetooth.receivers.BluetoothConnectionReceiver"
+                android:exported="true">
             <intent-filter>
                 <action android:name="android.intent.action.BOOT_COMPLETED" />
                 <action android:name="android.intent.action.MY_PACKAGE_REPLACED" />
@@ -42,9 +44,13 @@
             </intent-filter>
         </receiver>
 
-        <service android:name="com.maxtauro.airdroid.bluetooth.services.BluetoothConnectionService"/>
-        <service android:name="com.maxtauro.airdroid.notification.NotificationService"/>
-        <service android:name="com.maxtauro.airdroid.bluetooth.services.UnlockService"/>
+        <service android:name="com.maxtauro.airdroid.bluetooth.services.BluetoothConnectionService" />
+        <service android:name="com.maxtauro.airdroid.notification.NotificationService" />
+        <service android:name="com.maxtauro.airdroid.bluetooth.services.UnlockService" />
+        <service
+                android:name=".bluetooth.services.NotificationJobService"
+                android:label="Word service"
+                android:permission="android.permission.BIND_JOB_SERVICE" />
     </application>
 
 </manifest>
\ No newline at end of file
