Index: app/src/main/java/com/maxtauro/airdroid/MainActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.maxtauro.airdroid\n\nimport android.app.Activity\nimport android.app.AlertDialog\nimport android.bluetooth.BluetoothAdapter\nimport android.content.DialogInterface\nimport android.content.Intent\nimport android.content.pm.PackageManager\nimport android.os.Bundle\nimport android.view.View\nimport android.view.ViewGroup\nimport android.widget.Toast\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.core.app.ActivityCompat\nimport androidx.core.content.ContextCompat\nimport com.google.android.gms.ads.AdRequest\nimport com.google.android.gms.ads.AdSize\nimport com.google.android.gms.ads.AdView\nimport com.google.android.gms.ads.MobileAds\nimport com.google.android.material.floatingactionbutton.FloatingActionButton\nimport com.maxtauro.airdroid.mainfragment.DeviceStatusFragment\nimport com.maxtauro.airdroid.mainfragment.presenter.ReRenderIntent\n\nvar mIsActivityRunning = false\n\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var deviceStatusFragment: DeviceStatusFragment\n\n    lateinit var settingsButton: FloatingActionButton\n\n    private val bluetoothAdapter: BluetoothAdapter? = BluetoothAdapter.getDefaultAdapter()\n\n    private val REQUEST_ENABLE_BT = 1000 //TODO move this somewhere else\n    private val REQUEST_ENABLE_COARSE_LOCATION = 1001\n\n    private val isLocationPermissionEnabled\n        get() = ContextCompat.checkSelfPermission(\n            this,\n            android.Manifest.permission.ACCESS_FINE_LOCATION\n        ) == PackageManager.PERMISSION_GRANTED\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        setupAds()\n\n        deviceStatusFragment =\n            supportFragmentManager.findFragmentById(R.id.fragment_devices) as DeviceStatusFragment\n\n        settingsButton = findViewById(R.id.settings_btn)\n        settingsButton.setOnClickListener {\n            PreferenceDialog().show(supportFragmentManager, \"PreferenceDialog\")\n        }\n    }\n\n    override fun onStart() {\n        super.onStart()\n\n        if (!isLocationPermissionEnabled) {\n            showLocationPermissionDialog()\n        }\n\n        if (bluetoothAdapter == null) {\n            showBluetoothNotSupportedAlertDialog()\n        } else if (!bluetoothAdapter.isEnabled) {\n            val enableBtIntent = Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE)\n            startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT)\n        } else if (bluetoothAdapter.isEnabled) {\n            deviceStatusFragment.startBluetoothService()\n        }\n    }\n\n    // TODO, find more elegant way to check this\n    override fun onResume() {\n        super.onResume()\n        mIsActivityRunning = true\n    }\n\n    override fun onPause() {\n        super.onPause()\n        mIsActivityRunning = false\n    }\n\n    override fun onStop() {\n        super.onStop()\n        finish()\n    }\n\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n        if (requestCode == REQUEST_ENABLE_BT) {\n            if (resultCode == Activity.RESULT_OK) {\n                Toast.makeText(this, \"Bluetooth has been enabled\", Toast.LENGTH_SHORT).show()\n                deviceStatusFragment.startBluetoothService()\n            } else if (resultCode == Activity.RESULT_CANCELED) {\n                Toast.makeText(this, \"Bluetooth is not enabled\", Toast.LENGTH_SHORT).show()\n            }\n        }\n        super.onActivityResult(requestCode, resultCode, data)\n    }\n\n    override fun onRequestPermissionsResult(\n        requestCode: Int,\n        permissions: Array<out String>,\n        grantResults: IntArray\n    ) {\n        if (requestCode == REQUEST_ENABLE_COARSE_LOCATION) {\n            if (grantResults.firstOrNull() != PackageManager.PERMISSION_GRANTED &&\n                !ActivityCompat.shouldShowRequestPermissionRationale(\n                    this,\n                    android.Manifest.permission.ACCESS_FINE_LOCATION\n                )\n            ) {\n                showLocationPermissionDialog()\n            }\n            deviceStatusFragment.actionIntents().accept(ReRenderIntent)\n        }\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults)\n    }\n\n    private fun setupAds() {\n        MobileAds.initialize(this, getString(R.string.APP_AD_ID))\n\n        val adView = AdView(this)\n        adView.adSize = AdSize.BANNER\n        adView.adUnitId =\n            when {\n                BuildConfig.BUILD_TYPE == \"release\" || true -> getString(R.string.RELEASE_AD_UNIT_ID)\n                else -> TEST_AD_UNIT_ID\n            }\n\n        addContentView(\n            adView, ViewGroup.LayoutParams(\n                ViewGroup.LayoutParams.MATCH_PARENT,\n                ViewGroup.LayoutParams.WRAP_CONTENT\n            )\n        )\n\n        val adRequest =\n            AdRequest.Builder().addTestDevice(\"652EBD92D970E40C0A6C7619AE8FA570\").build()\n        adView.loadAd(adRequest)\n    }\n\n\n    private fun showBluetoothNotSupportedAlertDialog() {\n        AlertDialog\n            .Builder(this)\n            .setTitle(getString(R.string.bluetooth_not_supported))\n            .setMessage(getString(R.string.device_does_not_support_bluetooth))\n            .setPositiveButton(getString(R.string.positive_btn_label)) { _, _ ->\n                finish()\n            }\n            .show()\n    }\n\n    private fun showLocationPermissionDialog() {\n        AlertDialog.Builder(this)\n            .setMessage(getString(R.string.location_permission_explanation_message))\n            .setPositiveButton(getString(R.string.positive_btn_label)) { _: DialogInterface, _: Int ->\n                requestLocationPermission()\n            }\n            .setNegativeButton(getString(R.string.deny_btn_label)) { _: DialogInterface, _: Int ->\n                finish()\n            }\n            .setCancelable(false)\n            .create()\n            .show()\n    }\n\n    private fun requestLocationPermission() {\n        ActivityCompat.requestPermissions(\n            this,\n            arrayOf(android.Manifest.permission.ACCESS_FINE_LOCATION),\n            REQUEST_ENABLE_COARSE_LOCATION\n        )\n    }\n\n    fun closeWindow(view: View) {\n        finish()\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/maxtauro/airdroid/MainActivity.kt	(date 1567693487000)
+++ app/src/main/java/com/maxtauro/airdroid/MainActivity.kt	(date 1567718044000)
@@ -7,6 +7,7 @@
 import android.content.Intent
 import android.content.pm.PackageManager
 import android.os.Bundle
+import android.util.Log
 import android.view.View
 import android.view.ViewGroup
 import android.widget.Toast
@@ -44,6 +45,8 @@
         super.onCreate(savedInstanceState)
         setContentView(R.layout.activity_main)
 
+        Log.d("Main", "started activity")
+
         setupAds()
 
         deviceStatusFragment =
Index: app/src/main/java/com/maxtauro/airdroid/bluetooth/receivers/BluetoothConnectionReceiver.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.maxtauro.airdroid.bluetooth.receivers\n\nimport android.bluetooth.BluetoothA2dp\nimport android.bluetooth.BluetoothAdapter\nimport android.bluetooth.BluetoothDevice\nimport android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport android.util.Log\nimport com.maxtauro.airdroid.*\nimport com.maxtauro.airdroid.mainfragment.presenter.ConnectedIntent\nimport com.maxtauro.airdroid.mainfragment.presenter.DisconnectedIntent\nimport com.maxtauro.airdroid.notification.NotificationService\nimport org.greenrobot.eventbus.EventBus\n\nclass BluetoothConnectionReceiver : BroadcastReceiver() {\n\n    private val eventBus = EventBus.getDefault()\n\n    private val isActivityInForegroud: Boolean\n        get() = mIsActivityRunning\n\n    private val isConnected: Boolean\n        get() = BluetoothAdapter.getDefaultAdapter().getProfileConnectionState(BluetoothA2dp.HEADSET) == 1 ||\n                BluetoothAdapter.getDefaultAdapter().getProfileConnectionState(BluetoothA2dp.HEADSET) == 2\n\n    override fun onReceive(context: Context?, intent: Intent?) {\n        if (intent == null) return\n\n        when (intent.action) {\n            BluetoothDevice.ACTION_ACL_CONNECTED -> handleBluetoothConnected(intent, context)\n            BluetoothDevice.ACTION_ACL_DISCONNECTED -> handleBluetoothDisconnected(intent, context)\n            Intent.ACTION_BOOT_COMPLETED,\n            Intent.ACTION_MY_PACKAGE_REPLACED,\n            Intent.ACTION_PACKAGE_INSTALL -> {\n            }//TODO handle reboot\n        }\n    }\n\n    private fun handleBluetoothDisconnected(intent: Intent, context: Context?) {\n        val disconnectedDevice = intent.extras[BluetoothDevice.EXTRA_DEVICE] as? BluetoothDevice\n        disconnectedDevice?.let {\n            Log.d(\n                TAG,\n                \"Device Disconnected, Name: ${disconnectedDevice.name}, Address: ${disconnectedDevice.address}\"\n            )\n        }\n        if (isActivityInForegroud) {\n            eventBus.post(DisconnectedIntent)\n        } else {\n            context?.let {\n                NotificationService.clearNotification(context)\n                Intent(context, NotificationService::class.java).also {\n                    context.stopService(it)\n                }\n            }\n        }\n    }\n\n    private fun handleBluetoothConnected(intent: Intent, context: Context?) {\n        val connectedDevice = intent.extras[BluetoothDevice.EXTRA_DEVICE] as? BluetoothDevice\n        connectedDevice?.let {\n            Log.d(\n                TAG,\n                \"Device Connected, Name: ${connectedDevice.name}, Address: ${connectedDevice.address}\"\n            )\n\n            if (isActivityInForegroud) {\n                eventBus.post(ConnectedIntent(connectedDevice.name))\n            } else {\n                val preferences =\n                    context?.getSharedPreferences(SHARED_PREFERENCE_FILE_NAME, Context.MODE_PRIVATE)\n                        ?: throw IllegalStateException(\"Preferences haven't been initialized yet\")\n\n                val isOpenAppEnabled = preferences.getBoolean(OPEN_APP_PREF_KEY, true)\n                val isNotificationEnabled = preferences.getBoolean(NOTIFICATION_PREF_KEY, true)\n\n                if (isOpenAppEnabled) startMainActivity(context, connectedDevice)\n                else if (isNotificationEnabled) startNotificationService(context, connectedDevice)\n            }\n        }\n    }\n\n    private fun startNotificationService(context: Context, connectedDevice: BluetoothDevice) {\n        Intent(context, NotificationService::class.java).also { intent ->\n            intent.putExtra(NotificationService.EXTRA_AIRPOD_NAME, connectedDevice.name)\n            context.startServiceIfDeviceUnlocked(intent)\n        }\n    }\n\n    private fun startMainActivity(context: Context?, connectedDevice: BluetoothDevice) {\n        Intent(context, MainActivity::class.java).also { intent ->\n            intent.putExtra(EXTRA_DEVICE, connectedDevice)\n            intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK\n            context?.startActivity(intent)\n        }\n    }\n\n    companion object {\n        private const val TAG = \"BluetoothConnectionReceiver\"\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/maxtauro/airdroid/bluetooth/receivers/BluetoothConnectionReceiver.kt	(date 1567693487000)
+++ app/src/main/java/com/maxtauro/airdroid/bluetooth/receivers/BluetoothConnectionReceiver.kt	(date 1567717490000)
@@ -1,5 +1,6 @@
 package com.maxtauro.airdroid.bluetooth.receivers
 
+import android.annotation.SuppressLint
 import android.bluetooth.BluetoothA2dp
 import android.bluetooth.BluetoothAdapter
 import android.bluetooth.BluetoothDevice
@@ -7,25 +8,30 @@
 import android.content.Context
 import android.content.Intent
 import android.util.Log
-import com.maxtauro.airdroid.*
-import com.maxtauro.airdroid.mainfragment.presenter.ConnectedIntent
+import com.maxtauro.airdroid.EXTRA_DEVICE
+import com.maxtauro.airdroid.MainActivity
+import com.maxtauro.airdroid.mIsActivityRunning
 import com.maxtauro.airdroid.mainfragment.presenter.DisconnectedIntent
-import com.maxtauro.airdroid.notification.NotificationService
+import com.maxtauro.airdroid.notification.NotificationScannerUtil
 import org.greenrobot.eventbus.EventBus
 
 class BluetoothConnectionReceiver : BroadcastReceiver() {
 
     private val eventBus = EventBus.getDefault()
 
-    private val isActivityInForegroud: Boolean
+    private lateinit var notificationScannerUtil: NotificationScannerUtil
+
+    private val isActivityInForeground: Boolean
         get() = mIsActivityRunning
 
     private val isConnected: Boolean
         get() = BluetoothAdapter.getDefaultAdapter().getProfileConnectionState(BluetoothA2dp.HEADSET) == 1 ||
                 BluetoothAdapter.getDefaultAdapter().getProfileConnectionState(BluetoothA2dp.HEADSET) == 2
 
+    @SuppressLint("LongLogTag")
     override fun onReceive(context: Context?, intent: Intent?) {
         if (intent == null) return
+        Log.d(TAG, "Received intent: ${intent.action}")
 
         when (intent.action) {
             BluetoothDevice.ACTION_ACL_CONNECTED -> handleBluetoothConnected(intent, context)
@@ -37,6 +43,7 @@
         }
     }
 
+    @SuppressLint("LongLogTag")
     private fun handleBluetoothDisconnected(intent: Intent, context: Context?) {
         val disconnectedDevice = intent.extras[BluetoothDevice.EXTRA_DEVICE] as? BluetoothDevice
         disconnectedDevice?.let {
@@ -45,47 +52,60 @@
                 "Device Disconnected, Name: ${disconnectedDevice.name}, Address: ${disconnectedDevice.address}"
             )
         }
-        if (isActivityInForegroud) {
+        if (isActivityInForeground) {
             eventBus.post(DisconnectedIntent)
         } else {
-            context?.let {
-                NotificationService.clearNotification(context)
-                Intent(context, NotificationService::class.java).also {
-                    context.stopService(it)
-                }
-            }
+            context?.let { stopNotificationUtil() }
         }
     }
 
+    @SuppressLint("LongLogTag")
     private fun handleBluetoothConnected(intent: Intent, context: Context?) {
+
+        startMainActivity(
+            context = context,
+            connectedDevice = (intent.extras[BluetoothDevice.EXTRA_DEVICE] as? BluetoothDevice)!!
+            )
         val connectedDevice = intent.extras[BluetoothDevice.EXTRA_DEVICE] as? BluetoothDevice
-        connectedDevice?.let {
-            Log.d(
-                TAG,
-                "Device Connected, Name: ${connectedDevice.name}, Address: ${connectedDevice.address}"
-            )
-
-            if (isActivityInForegroud) {
-                eventBus.post(ConnectedIntent(connectedDevice.name))
-            } else {
-                val preferences =
-                    context?.getSharedPreferences(SHARED_PREFERENCE_FILE_NAME, Context.MODE_PRIVATE)
-                        ?: throw IllegalStateException("Preferences haven't been initialized yet")
-
-                val isOpenAppEnabled = preferences.getBoolean(OPEN_APP_PREF_KEY, true)
-                val isNotificationEnabled = preferences.getBoolean(NOTIFICATION_PREF_KEY, true)
-
-                if (isOpenAppEnabled) startMainActivity(context, connectedDevice)
-                else if (isNotificationEnabled) startNotificationService(context, connectedDevice)
-            }
-        }
+//        connectedDevice?.let {
+//            Log.d(
+//                TAG,
+//                "Device Connected, Name: ${connectedDevice.name}, Address: ${connectedDevice.address}"
+//            )
+//
+//            if (isActivityInForeground) {
+//                eventBus.post(ConnectedIntent(connectedDevice.name))
+//            } else {
+//                val preferences =
+//                    context?.getSharedPreferences(SHARED_PREFERENCE_FILE_NAME, Context.MODE_PRIVATE)
+//                        ?: throw IllegalStateException("Preferences haven't been initialized yet")
+//
+//                val isOpenAppEnabled = preferences.getBoolean(OPEN_APP_PREF_KEY, true)
+//                val isNotificationEnabled = preferences.getBoolean(NOTIFICATION_PREF_KEY, true)
+//
+//                if (isOpenAppEnabled && context.isDeviceUnlocked()) {
+//                    startMainActivity(
+//                        context = context,
+//                        connectedDevice = connectedDevice
+//                    )
+//                } else if (isNotificationEnabled) {
+//                    startNotificationUtil(
+//                        context = context,
+//                        connectedDevice = connectedDevice
+//                    )
+//                }
+//            }
+//        }
+    }
+
+    private fun startNotificationUtil(context: Context, connectedDevice: BluetoothDevice) {
+        notificationScannerUtil = NotificationScannerUtil(context.packageName)
+        notificationScannerUtil.initializeNotificationUtil(context)
+        notificationScannerUtil.startScan()
     }
 
-    private fun startNotificationService(context: Context, connectedDevice: BluetoothDevice) {
-        Intent(context, NotificationService::class.java).also { intent ->
-            intent.putExtra(NotificationService.EXTRA_AIRPOD_NAME, connectedDevice.name)
-            context.startServiceIfDeviceUnlocked(intent)
-        }
+    private fun stopNotificationUtil() {
+        notificationScannerUtil.stopScan()
     }
 
     private fun startMainActivity(context: Context?, connectedDevice: BluetoothDevice) {
Index: app/src/main/java/com/maxtauro/airdroid/utils/BluetoothScannerUtil.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.maxtauro.airdroid.utils\n\nimport android.bluetooth.BluetoothAdapter\nimport android.bluetooth.le.ScanCallback\nimport android.bluetooth.le.ScanFilter\nimport android.bluetooth.le.ScanResult\nimport android.bluetooth.le.ScanSettings\nimport android.util.Log\n\nclass BluetoothScannerUtil {\n\n    private val bluetoothAdapter = BluetoothAdapter.getDefaultAdapter()\n\n    private val scanner = bluetoothAdapter?.bluetoothLeScanner\n    private val scanFilters = getScanFilters()\n\n    var isScanning: Boolean = false\n        private set\n\n    fun startScan(scanCallback: ScanCallback, scanMode: Int) {\n        if (isScanning) return\n\n        val scanSettings = ScanSettings.Builder().setScanMode(scanMode).setReportDelay(2).build()\n\n        Log.d(TAG, \"Starting bluetooth scan\")\n        scanner?.startScan(scanFilters, scanSettings, scanCallback)\n        isScanning = true\n    }\n\n    private fun getScanFilters(): List<ScanFilter> {\n        val manufacturerData = ByteArray(27)\n        val manufacturerDataMask = ByteArray(27)\n\n        manufacturerData[0] = 7\n        manufacturerData[1] = 25\n\n        manufacturerDataMask[0] = -1\n        manufacturerDataMask[1] = -1\n\n        val builder = ScanFilter.Builder()\n        builder.setManufacturerData(76, manufacturerData, manufacturerDataMask)\n        return listOf(builder.build())\n    }\n\n    fun stopScan() {\n        scanner?.stopScan(object : ScanCallback() {\n            override fun onScanResult(callbackType: Int, result: ScanResult) {\n            }\n        })\n\n        isScanning = false\n    }\n\n    companion object {\n        private const val TAG = \"BluetoothScannerUtil\"\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/maxtauro/airdroid/utils/BluetoothScannerUtil.kt	(date 1567693487000)
+++ app/src/main/java/com/maxtauro/airdroid/utils/BluetoothScannerUtil.kt	(date 1567706949000)
@@ -43,6 +43,8 @@
     }
 
     fun stopScan() {
+        if (!isScanning) return
+
         scanner?.stopScan(object : ScanCallback() {
             override fun onScanResult(callbackType: Int, result: ScanResult) {
             }
Index: app/src/main/java/com/maxtauro/airdroid/notification/NotificationScannerUtil.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/maxtauro/airdroid/notification/NotificationScannerUtil.kt	(date 1567706839000)
+++ app/src/main/java/com/maxtauro/airdroid/notification/NotificationScannerUtil.kt	(date 1567706839000)
@@ -0,0 +1,159 @@
+package com.maxtauro.airdroid.notification
+
+import android.app.Notification
+import android.app.NotificationChannel
+import android.app.NotificationManager
+import android.app.PendingIntent
+import android.bluetooth.le.ScanSettings
+import android.content.Context
+import android.content.Intent
+import android.content.SharedPreferences
+import android.os.Build
+import android.util.Log
+import androidx.core.app.NotificationCompat
+import com.maxtauro.airdroid.*
+import com.maxtauro.airdroid.bluetooth.callbacks.AirpodLeScanCallback
+import com.maxtauro.airdroid.utils.BluetoothScannerUtil
+
+/**
+ *  This class is to be used to user the bluetooth scanner
+ *  and publish scan updates to the notification for the user to see
+ **/
+
+class NotificationScannerUtil(packageName: String) {
+
+    private val scannerUtil = BluetoothScannerUtil()
+
+    private val scanCallback = AirpodLeScanCallback(::onScanResult)
+
+    private lateinit var context: Context
+
+    private lateinit var preferences: SharedPreferences
+
+    private var isNotificationUtilInitialized = false
+
+    private lateinit var notificationManager: NotificationManager
+    private lateinit var notificationBuilder: NotificationCompat.Builder
+
+    private lateinit var largeNotificationView: NotificationView
+    private lateinit var smallNotificationView: NotificationView
+
+    private lateinit var airpodName: String
+    private lateinit var airpodModel: AirpodModel
+
+    init {
+        bindViews(packageName)
+    }
+
+    fun initializeNotificationUtil(context: Context) {
+        this.context = context
+
+        preferences = context.getSharedPreferences(
+            SHARED_PREFERENCE_FILE_NAME, Context.MODE_PRIVATE
+        )
+            ?: throw IllegalStateException("Preferences haven't been initialized yet")
+
+        notificationManager =
+            context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+        notificationBuilder = NotificationCompat.Builder(context, TAG)
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { //on oreo and newer, create a notification channel
+            val channel = NotificationChannel(TAG, TAG, NotificationManager.IMPORTANCE_DEFAULT)
+            channel.enableVibration(false)
+            channel.enableLights(false)
+            channel.setSound(null, null)
+            channel.setShowBadge(true)
+            channel.lockscreenVisibility = Notification.VISIBILITY_PUBLIC
+            notificationManager.createNotificationChannel(channel)
+        }
+
+        notificationBuilder.setShowWhen(false)
+        notificationBuilder.setOngoing(true)
+
+        notificationBuilder.setCustomContentView(smallNotificationView)
+        notificationBuilder.setCustomBigContentView(largeNotificationView)
+
+        isNotificationUtilInitialized = true
+    }
+
+    fun startScan(airpodModel: AirpodModel) {
+        checkIsInitialized()
+        renderNotification(airpodModel)
+        startScan()
+    }
+
+    fun startScan() {
+        checkIsInitialized()
+        scannerUtil.startScan(
+            scanCallback = scanCallback,
+            scanMode = ScanSettings.SCAN_MODE_LOW_POWER
+        )
+    }
+
+    fun stopScan() {
+        checkIsInitialized()
+        scannerUtil.stopScan()
+        clearNotification(context)
+    }
+
+    private fun bindViews(packageName: String) {
+        largeNotificationView =
+            NotificationView(isLargeNotification = true, packageName = packageName)
+        smallNotificationView =
+            NotificationView(isLargeNotification = false, packageName = packageName)
+    }
+
+    private fun onScanResult(airpodModel: AirpodModel) {
+        if (scannerUtil.isScanning) {
+            renderNotification(airpodModel)
+        } else clearNotification(context)
+    }
+
+    private fun renderNotification(airpodModel: AirpodModel) {
+        val isNotificationEnabled = preferences.getBoolean(NOTIFICATION_PREF_KEY, true)
+
+        if (airpodModel.isConnected && isNotificationEnabled) {
+            this.airpodModel = airpodModel
+
+            if (airpodModel.leftAirpod.isConnected && !airpodModel.rightAirpod.isConnected) {
+                notificationBuilder.setSmallIcon(R.mipmap.left_airpod_notification_icon)
+            } else if (!airpodModel.leftAirpod.isConnected && airpodModel.rightAirpod.isConnected) {
+                notificationBuilder.setSmallIcon(R.mipmap.right_airpod_notification_icon)
+            } else {
+                notificationBuilder.setSmallIcon(R.mipmap.both_airpods_notification_icon)
+            }
+
+            notificationBuilder.setContentIntent(buildContentIntent(airpodModel))
+
+            largeNotificationView.render(airpodModel)
+            smallNotificationView.render(airpodModel)
+            notificationManager.notify(1, notificationBuilder.build())
+        }
+    }
+
+    private fun buildContentIntent(airpodModel: AirpodModel): PendingIntent? {
+        val intent = Intent(context, MainActivity::class.java)
+        intent.putExtra(NotificationService.EXTRA_AIRPOD_MODEL, airpodModel)
+        return PendingIntent.getActivity(
+            context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT
+        )
+    }
+
+    private fun checkIsInitialized() = check(isNotificationUtilInitialized) {
+        "Must call NotificationScannerUtil.initializeNotificationUtil before scanning"
+    }
+
+    companion object {
+        const val EXTRA_AIRPOD_MODEL = "EXTRA_AIRPOD_MODEL"
+        const val EXTRA_AIRPOD_NAME = "EXTRA_AIRPOD_NAME"
+
+        private const val TAG = "NotificationScannerUtil"
+
+        fun clearNotification(context: Context) {
+            Log.d(TAG, "Clearing notification from: $context")
+            val notificationManager =
+                context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+            notificationManager.cancelAll()
+        }
+    }
+}
\ No newline at end of file
Index: app/src/main/java/com/maxtauro/airdroid/notification/NotificationService.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.maxtauro.airdroid.notification\n\nimport android.app.*\nimport android.bluetooth.le.ScanSettings\nimport android.content.Context\nimport android.content.Intent\nimport android.content.SharedPreferences\nimport android.os.Build\nimport android.os.IBinder\nimport android.util.Log\nimport androidx.core.app.NotificationCompat\nimport com.maxtauro.airdroid.*\nimport com.maxtauro.airdroid.bluetooth.callbacks.AirpodLeScanCallback\nimport com.maxtauro.airdroid.mainfragment.presenter.RefreshIntent\nimport com.maxtauro.airdroid.mainfragment.presenter.UpdateNameIntent\nimport com.maxtauro.airdroid.utils.BluetoothScannerUtil\nimport org.greenrobot.eventbus.EventBus\n\nclass NotificationService : Service() {\n\n    private val scannerUtil = BluetoothScannerUtil()\n\n    private val scanCallback = AirpodLeScanCallback(::onScanResult)\n\n    private lateinit var preferences: SharedPreferences\n\n    private var isNotificationEnabled = true\n\n    private lateinit var notificationManager: NotificationManager\n    private lateinit var notificationBuilder: NotificationCompat.Builder\n\n    private lateinit var largeNotificationView: NotificationView\n    private lateinit var smallNotificationView: NotificationView\n\n    private lateinit var airpodName: String\n    private lateinit var airpodModel: AirpodModel\n\n    override fun onCreate() {\n        super.onCreate()\n\n        bindViews()\n\n        preferences = baseContext?.getSharedPreferences(SHARED_PREFERENCE_FILE_NAME ,Context.MODE_PRIVATE)\n            ?: throw IllegalStateException(\"Preferences haven't been initialized yet\")\n\n        isNotificationEnabled = preferences.getBoolean(NOTIFICATION_PREF_KEY, true)\n\n        notificationManager = baseContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\n        notificationBuilder = NotificationCompat.Builder(baseContext, TAG)\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { //on oreo and newer, create a notification channel\n            val channel = NotificationChannel(TAG, TAG, NotificationManager.IMPORTANCE_DEFAULT)\n            channel.enableVibration(false)\n            channel.enableLights(false)\n            channel.setSound(null, null)\n            channel.setShowBadge(true)\n            channel.lockscreenVisibility = Notification.VISIBILITY_PUBLIC\n            notificationManager.createNotificationChannel(channel)\n        }\n\n        notificationBuilder.setShowWhen(false)\n        notificationBuilder.setOngoing(true)\n\n        notificationBuilder.setCustomContentView(smallNotificationView)\n        notificationBuilder.setCustomBigContentView(largeNotificationView)\n    }\n\n    private fun bindViews() {\n        largeNotificationView = NotificationView(isLargeNotification = true, packageName = packageName)\n        smallNotificationView = NotificationView(isLargeNotification = false, packageName = packageName)\n    }\n\n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        if (isNotificationEnabled) {\n            Log.d(TAG, \"Starting NotificationService\")\n\n            intent?.getStringExtra(EXTRA_AIRPOD_NAME)?.let { airpodName = it }\n            (intent?.getParcelableExtra(EXTRA_AIRPOD_MODEL) as? AirpodModel)?.let {\n                airpodModel = it\n                renderNotification(it)\n            }\n\n            scannerUtil.startScan(\n                scanCallback = scanCallback,\n                scanMode = if (mIsActivityRunning) {\n                    ScanSettings.SCAN_MODE_LOW_LATENCY\n                } else {\n                    ScanSettings.SCAN_MODE_LOW_POWER\n                })\n        }\n\n        return super.onStartCommand(intent, flags, startId)\n    }\n\n    override fun onBind(intent: Intent?): IBinder? {\n        return null\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n\n        // TODO find a way to do this without using event bus\n        if (::airpodModel.isInitialized) EventBus.getDefault().post(RefreshIntent(airpodModel))\n        if (::airpodName.isInitialized) EventBus.getDefault().post(UpdateNameIntent(airpodName))\n\n        scannerUtil.stopScan()\n    }\n\n    private fun onScanResult(airpodModel: AirpodModel) {\n        if (scannerUtil.isScanning) {\n            renderNotification(airpodModel)\n        }\n    }\n\n    private fun renderNotification(airpodModel: AirpodModel) {\n        if (airpodModel.isConnected && isNotificationEnabled) {\n            this.airpodModel = airpodModel\n\n            if (airpodModel.leftAirpod.isConnected && !airpodModel.rightAirpod.isConnected) {\n                notificationBuilder.setSmallIcon(R.mipmap.left_airpod_notification_icon)\n            } else if (!airpodModel.leftAirpod.isConnected && airpodModel.rightAirpod.isConnected) {\n                notificationBuilder.setSmallIcon(R.mipmap.right_airpod_notification_icon)\n            } else {\n                notificationBuilder.setSmallIcon(R.mipmap.both_airpods_notification_icon)\n            }\n\n            notificationBuilder.setContentIntent(buildContentIntent(airpodModel))\n\n            largeNotificationView.render(airpodModel)\n            smallNotificationView.render(airpodModel)\n            notificationManager.notify(1, notificationBuilder.build())\n        } else clearNotification(baseContext)\n    }\n\n    private fun buildContentIntent(airpodModel: AirpodModel): PendingIntent? {\n        val intent = Intent(applicationContext, MainActivity::class.java)\n        intent.putExtra(EXTRA_AIRPOD_MODEL, airpodModel)\n        return PendingIntent.getActivity(\n            this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT\n        )\n    }\n\n    companion object {\n        const val EXTRA_AIRPOD_MODEL = \"EXTRA_AIRPOD_MODEL\"\n        const val EXTRA_AIRPOD_NAME = \"EXTRA_AIRPOD_NAME\"\n\n        private const val TAG = \"NotificationService\"\n\n        fun clearNotification(context: Context) {\n            Log.d(TAG, \"Clearing notification from: $context\")\n            val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\n            notificationManager.cancelAll()\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/maxtauro/airdroid/notification/NotificationService.kt	(date 1567693487000)
+++ app/src/main/java/com/maxtauro/airdroid/notification/NotificationService.kt	(date 1567706839000)
@@ -1,36 +1,22 @@
 package com.maxtauro.airdroid.notification
 
-import android.app.*
-import android.bluetooth.le.ScanSettings
+import android.app.NotificationManager
+import android.app.Service
 import android.content.Context
 import android.content.Intent
-import android.content.SharedPreferences
-import android.os.Build
 import android.os.IBinder
 import android.util.Log
-import androidx.core.app.NotificationCompat
-import com.maxtauro.airdroid.*
-import com.maxtauro.airdroid.bluetooth.callbacks.AirpodLeScanCallback
+import com.maxtauro.airdroid.AirpodModel
 import com.maxtauro.airdroid.mainfragment.presenter.RefreshIntent
 import com.maxtauro.airdroid.mainfragment.presenter.UpdateNameIntent
-import com.maxtauro.airdroid.utils.BluetoothScannerUtil
 import org.greenrobot.eventbus.EventBus
 
+@Deprecated("Try to just use notification util here")
 class NotificationService : Service() {
 
-    private val scannerUtil = BluetoothScannerUtil()
-
-    private val scanCallback = AirpodLeScanCallback(::onScanResult)
-
-    private lateinit var preferences: SharedPreferences
-
     private var isNotificationEnabled = true
 
-    private lateinit var notificationManager: NotificationManager
-    private lateinit var notificationBuilder: NotificationCompat.Builder
-
-    private lateinit var largeNotificationView: NotificationView
-    private lateinit var smallNotificationView: NotificationView
+    private lateinit var notificationScannerUtil: NotificationScannerUtil
 
     private lateinit var airpodName: String
     private lateinit var airpodModel: AirpodModel
@@ -38,36 +24,8 @@
     override fun onCreate() {
         super.onCreate()
 
-        bindViews()
-
-        preferences = baseContext?.getSharedPreferences(SHARED_PREFERENCE_FILE_NAME ,Context.MODE_PRIVATE)
-            ?: throw IllegalStateException("Preferences haven't been initialized yet")
-
-        isNotificationEnabled = preferences.getBoolean(NOTIFICATION_PREF_KEY, true)
-
-        notificationManager = baseContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
-        notificationBuilder = NotificationCompat.Builder(baseContext, TAG)
-
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { //on oreo and newer, create a notification channel
-            val channel = NotificationChannel(TAG, TAG, NotificationManager.IMPORTANCE_DEFAULT)
-            channel.enableVibration(false)
-            channel.enableLights(false)
-            channel.setSound(null, null)
-            channel.setShowBadge(true)
-            channel.lockscreenVisibility = Notification.VISIBILITY_PUBLIC
-            notificationManager.createNotificationChannel(channel)
-        }
-
-        notificationBuilder.setShowWhen(false)
-        notificationBuilder.setOngoing(true)
-
-        notificationBuilder.setCustomContentView(smallNotificationView)
-        notificationBuilder.setCustomBigContentView(largeNotificationView)
-    }
-
-    private fun bindViews() {
-        largeNotificationView = NotificationView(isLargeNotification = true, packageName = packageName)
-        smallNotificationView = NotificationView(isLargeNotification = false, packageName = packageName)
+        notificationScannerUtil = NotificationScannerUtil(packageName)
+        notificationScannerUtil.initializeNotificationUtil(applicationContext)
     }
 
     override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
@@ -77,16 +35,9 @@
             intent?.getStringExtra(EXTRA_AIRPOD_NAME)?.let { airpodName = it }
             (intent?.getParcelableExtra(EXTRA_AIRPOD_MODEL) as? AirpodModel)?.let {
                 airpodModel = it
-                renderNotification(it)
             }
 
-            scannerUtil.startScan(
-                scanCallback = scanCallback,
-                scanMode = if (mIsActivityRunning) {
-                    ScanSettings.SCAN_MODE_LOW_LATENCY
-                } else {
-                    ScanSettings.SCAN_MODE_LOW_POWER
-                })
+            notificationScannerUtil.startScan(airpodModel)
         }
 
         return super.onStartCommand(intent, flags, startId)
@@ -103,41 +54,7 @@
         if (::airpodModel.isInitialized) EventBus.getDefault().post(RefreshIntent(airpodModel))
         if (::airpodName.isInitialized) EventBus.getDefault().post(UpdateNameIntent(airpodName))
 
-        scannerUtil.stopScan()
-    }
-
-    private fun onScanResult(airpodModel: AirpodModel) {
-        if (scannerUtil.isScanning) {
-            renderNotification(airpodModel)
-        }
-    }
-
-    private fun renderNotification(airpodModel: AirpodModel) {
-        if (airpodModel.isConnected && isNotificationEnabled) {
-            this.airpodModel = airpodModel
-
-            if (airpodModel.leftAirpod.isConnected && !airpodModel.rightAirpod.isConnected) {
-                notificationBuilder.setSmallIcon(R.mipmap.left_airpod_notification_icon)
-            } else if (!airpodModel.leftAirpod.isConnected && airpodModel.rightAirpod.isConnected) {
-                notificationBuilder.setSmallIcon(R.mipmap.right_airpod_notification_icon)
-            } else {
-                notificationBuilder.setSmallIcon(R.mipmap.both_airpods_notification_icon)
-            }
-
-            notificationBuilder.setContentIntent(buildContentIntent(airpodModel))
-
-            largeNotificationView.render(airpodModel)
-            smallNotificationView.render(airpodModel)
-            notificationManager.notify(1, notificationBuilder.build())
-        } else clearNotification(baseContext)
-    }
-
-    private fun buildContentIntent(airpodModel: AirpodModel): PendingIntent? {
-        val intent = Intent(applicationContext, MainActivity::class.java)
-        intent.putExtra(EXTRA_AIRPOD_MODEL, airpodModel)
-        return PendingIntent.getActivity(
-            this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT
-        )
+        notificationScannerUtil.stopScan()
     }
 
     companion object {
@@ -148,7 +65,8 @@
 
         fun clearNotification(context: Context) {
             Log.d(TAG, "Clearing notification from: $context")
-            val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+            val notificationManager =
+                context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
             notificationManager.cancelAll()
         }
     }
Index: app/src/main/java/com/maxtauro/airdroid/bluetooth/services/UnlockService.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.maxtauro.airdroid.bluetooth.services\n\nimport android.app.Service\nimport android.bluetooth.BluetoothAdapter\nimport android.content.Intent\nimport android.content.Intent.ACTION_USER_PRESENT\nimport android.content.IntentFilter\nimport android.os.IBinder\nimport android.util.Log\nimport com.maxtauro.airdroid.bluetooth.receivers.UnlockReceiver\n\n/** This Service is used to register a receiver for when the device\n *  is unlocked and airpods were connected while the device was locked\n */\nclass UnlockService : Service() {\n\n    private val bluetoothAdapter = BluetoothAdapter.getDefaultAdapter()\n\n    private val unlockReceiver = UnlockReceiver()\n    private var isReceiverRegistered = false\n\n    private val userPresentIntentFilter = IntentFilter(ACTION_USER_PRESENT)\n\n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        if (bluetoothAdapter == null) {\n            Log.d(TAG, \"Device Doesn't support bluetooth, UnlockService won't run\")\n            stopSelf() // If the device does not support bluetooth, the service doesn't run\n            return super.onStartCommand(intent, flags, startId)\n        }\n\n        registerReceiver(unlockReceiver, userPresentIntentFilter)\n        isReceiverRegistered = true\n        Log.d(TAG, \"Service Started\")\n        return super.onStartCommand(intent, flags, startId)\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        if (isReceiverRegistered) {\n            unregisterReceiver(unlockReceiver)\n            isReceiverRegistered = false\n        }\n        Log.d(TAG, \"Service stopped\")\n\n    }\n\n    override fun onBind(intent: Intent?): IBinder? {\n        return null\n    }\n\n    companion object {\n        private const val TAG = \"UnlockService\"\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/maxtauro/airdroid/bluetooth/services/UnlockService.kt	(date 1567693487000)
+++ app/src/main/java/com/maxtauro/airdroid/bluetooth/services/UnlockService.kt	(date 1567695003000)
@@ -3,6 +3,7 @@
 import android.app.Service
 import android.bluetooth.BluetoothAdapter
 import android.content.Intent
+import android.content.Intent.ACTION_SCREEN_ON
 import android.content.Intent.ACTION_USER_PRESENT
 import android.content.IntentFilter
 import android.os.IBinder
@@ -20,6 +21,7 @@
     private var isReceiverRegistered = false
 
     private val userPresentIntentFilter = IntentFilter(ACTION_USER_PRESENT)
+    private val screenOnIntentFilter = IntentFilter(ACTION_SCREEN_ON)
 
     override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
         if (bluetoothAdapter == null) {
@@ -29,6 +31,8 @@
         }
 
         registerReceiver(unlockReceiver, userPresentIntentFilter)
+        registerReceiver(unlockReceiver, screenOnIntentFilter)
+
         isReceiverRegistered = true
         Log.d(TAG, "Service Started")
         return super.onStartCommand(intent, flags, startId)
Index: app/src/main/java/com/maxtauro/airdroid/bluetooth/receivers/UnlockServiceStarter.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.maxtauro.airdroid.bluetooth.receivers\n\nimport android.content.BroadcastReceiver\nimport android.content.Context\nimport android.content.Intent\nimport com.maxtauro.airdroid.bluetooth.services.UnlockService\n\n/** This class acts as a starter for the UnlockService class.\n *\n *  We need to use this class for the UnlockService since we\n *  can't register USER_PRESENT in the manifest so it must\n *  be done programmatically in the UnlockService\n */\nclass UnlockServiceStarter : BroadcastReceiver() {\n    override fun onReceive(context: Context?, intent: Intent?) {\n        context?.startService(Intent(context, UnlockService::class.java))\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/maxtauro/airdroid/bluetooth/receivers/UnlockServiceStarter.kt	(date 1567693487000)
+++ app/src/main/java/com/maxtauro/airdroid/bluetooth/receivers/UnlockServiceStarter.kt	(date 1567694511000)
@@ -3,7 +3,9 @@
 import android.content.BroadcastReceiver
 import android.content.Context
 import android.content.Intent
+import android.util.Log
 import com.maxtauro.airdroid.bluetooth.services.UnlockService
+import com.maxtauro.airdroid.startServiceIfDeviceUnlocked
 
 /** This class acts as a starter for the UnlockService class.
  *
@@ -13,6 +15,11 @@
  */
 class UnlockServiceStarter : BroadcastReceiver() {
     override fun onReceive(context: Context?, intent: Intent?) {
-        context?.startService(Intent(context, UnlockService::class.java))
+        Log.d(TAG, "Received: ${intent?.action}")
+        context?.startServiceIfDeviceUnlocked(Intent(context, UnlockService::class.java))
+    }
+
+    companion object {
+         private const val TAG = "UnlockServiceStarter"
     }
 }
\ No newline at end of file
Index: app/src/main/java/com/maxtauro/airdroid/Constants.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.maxtauro.airdroid\n\nimport android.app.KeyguardManager\nimport android.content.Context\nimport android.content.Intent\nimport android.util.Log\nimport com.crashlytics.android.Crashlytics\n\nconst val EXTRA_DEVICE_ADDRESS = \"DEVICE_ADDRESS\"\nconst val EXTRA_DEVICE = \"EXTRA_DEVICE\"\n\nconst val TEST_AD_UNIT_ID = \"ca-app-pub-3940256099942544/6300978111\"\n\nconst val SHARED_PREFERENCE_FILE_NAME = \"AirDroid.SHARED_PREFERENCE_FILE_NAME\"\nconst val NOTIFICATION_PREF_KEY = \"9999\"\nconst val OPEN_APP_PREF_KEY = \"9998\"\n\ninline fun <R> R?.orElse(block: () -> R): R {\n    return this ?: block()\n}\n\nfun Context?.startServiceIfDeviceUnlocked(intent: Intent) {\n    val keyguardManager = this?.getSystemService(Context.KEYGUARD_SERVICE) as KeyguardManager\n    if (!keyguardManager.isKeyguardLocked) {\n        this.startService(intent)\n        Log.d(this.javaClass.simpleName, \"Started service with intent: $intent\")\n    } else {\n        val msg = \"Device locked, did not start service with intent: $intent\"\n        Crashlytics.logException(IllegalStateException(msg))\n        Log.d(this.javaClass.simpleName, msg)\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/maxtauro/airdroid/Constants.kt	(date 1567693487000)
+++ app/src/main/java/com/maxtauro/airdroid/Constants.kt	(date 1567703991000)
@@ -7,26 +7,32 @@
 import com.crashlytics.android.Crashlytics
 
 const val EXTRA_DEVICE_ADDRESS = "DEVICE_ADDRESS"
+
 const val EXTRA_DEVICE = "EXTRA_DEVICE"
-
 const val TEST_AD_UNIT_ID = "ca-app-pub-3940256099942544/6300978111"
 
 const val SHARED_PREFERENCE_FILE_NAME = "AirDroid.SHARED_PREFERENCE_FILE_NAME"
+
 const val NOTIFICATION_PREF_KEY = "9999"
 const val OPEN_APP_PREF_KEY = "9998"
-
 inline fun <R> R?.orElse(block: () -> R): R {
     return this ?: block()
 }
 
-fun Context?.startServiceIfDeviceUnlocked(intent: Intent) {
+fun Context?.isDeviceUnlocked(): Boolean{
     val keyguardManager = this?.getSystemService(Context.KEYGUARD_SERVICE) as KeyguardManager
-    if (!keyguardManager.isKeyguardLocked) {
-        this.startService(intent)
-        Log.d(this.javaClass.simpleName, "Started service with intent: $intent")
+    return !keyguardManager.isKeyguardLocked
+}
+
+fun Context?.startServiceIfDeviceUnlocked(intent: Intent) {
+    if (!isDeviceUnlocked() && mIsActivityRunning) {
+        this?.let {
+            this.startService(intent)
+            Log.d(this.javaClass.simpleName, "Started service with intent: $intent")
+        }
     } else {
         val msg = "Device locked, did not start service with intent: $intent"
         Crashlytics.logException(IllegalStateException(msg))
-        Log.d(this.javaClass.simpleName, msg)
+        Log.d(this?.javaClass?.simpleName, msg)
     }
-}
\ No newline at end of file
+}
Index: app/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        package=\"com.maxtauro.airdroid\">\n\n    <uses-permission android:name=\"android.permission.BLUETOOTH\"/>\n    <uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\"/>\n    <uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\"/>\n    <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/>\n    <uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"/>\n\n    <uses-feature\n        android:name=\"android.hardware.bluetooth_le\"\n        android:required=\"true\"/>\n\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme.Transparent\">\n\n        <meta-data\n                android:name=\"com.google.android.gms.ads.APPLICATION_ID\"\n                android:value=\"@string/APP_AD_ID\"/>\n\n        <activity android:name=\"com.maxtauro.airdroid.MainActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\"/>\n\n                <category android:name=\"android.intent.category.LAUNCHER\"/>\n            </intent-filter>\n        </activity>\n\n        <receiver android:name=\"com.maxtauro.airdroid.bluetooth.receivers.BluetoothConnectionReceiver\"  android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.BOOT_COMPLETED\" />\n                <action android:name=\"android.intent.action.MY_PACKAGE_REPLACED\" />\n                <action android:name=\"android.intent.action.PACKAGE_INSTALL\" />\n                <action android:name=\"android.bluetooth.device.action.ACL_CONNECTED\" />\n                <action android:name=\"android.bluetooth.device.action.ACL_DISCONNECTED\" />\n            </intent-filter>\n        </receiver>\n\n        <service android:name=\"com.maxtauro.airdroid.bluetooth.services.BluetoothConnectionService\"/>\n        <service android:name=\"com.maxtauro.airdroid.notification.NotificationService\"/>\n        <service android:name=\"com.maxtauro.airdroid.bluetooth.services.UnlockService\"/>\n    </application>\n\n</manifest>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/AndroidManifest.xml	(date 1567693487000)
+++ app/src/main/AndroidManifest.xml	(date 1567707581000)
@@ -42,9 +42,20 @@
             </intent-filter>
         </receiver>
 
+        <receiver android:name=".bluetooth.receivers.UnlockServiceStarter" android:exported="true">
+            <intent-filter>
+                <action android:name="android.intent.action.BOOT_COMPLETED" />
+                <action android:name="android.intent.action.MY_PACKAGE_REPLACED" />
+                <action android:name="android.intent.action.PACKAGE_INSTALL" />
+                <action android:name="android.bluetooth.device.action.ACL_CONNECTED" />
+                <action android:name="android.bluetooth.device.action.ACL_DISCONNECTED" />
+            </intent-filter>
+        </receiver>
+
         <service android:name="com.maxtauro.airdroid.bluetooth.services.BluetoothConnectionService"/>
         <service android:name="com.maxtauro.airdroid.notification.NotificationService"/>
         <service android:name="com.maxtauro.airdroid.bluetooth.services.UnlockService"/>
+        <service android:name=".notification.NotificationIntentService" />
     </application>
 
 </manifest>
\ No newline at end of file
